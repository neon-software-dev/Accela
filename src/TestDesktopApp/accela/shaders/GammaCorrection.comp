#version 450

//
// Definitions
//
const uint POST_EFFECT_LOCAL_SIZE_X = 16;
const uint POST_EFFECT_LOCAL_SIZE_Y = 16;
const uint POST_EFFECT_LOCAL_SIZE_Z = 1;

//
// Inputs
//
layout(push_constant) uniform constants
{
    uint renderWidth;
    uint renderHeight;
    float gamma;
} PushConstants;

layout (set = 0, binding = 0) uniform sampler2DArray i_inputImage;
layout (set = 0, binding = 1, rgba8) uniform image2DArray i_outputImage;

layout (local_size_x = POST_EFFECT_LOCAL_SIZE_X,
        local_size_y = POST_EFFECT_LOCAL_SIZE_Y,
        local_size_z = POST_EFFECT_LOCAL_SIZE_Z) in;

vec4 DoWork(int layerIndex)
{
    const vec2 inUV = {
        (float(gl_GlobalInvocationID.x) + 0.5f) / float(PushConstants.renderWidth),
        (float(gl_GlobalInvocationID.y) + 0.5f) / float(PushConstants.renderHeight),
    };

    vec4 inPixel = texture(i_inputImage, vec3(inUV, layerIndex));

    const vec3 srgb = pow(inPixel.rgb, vec3(1.0f / PushConstants.gamma));

    return vec4(srgb, inPixel.a);
}

void main()
{
    // Ignore out of render size work invocations (for when a render dimension isn't cleanly divisible by
    // the local group size).
    if (gl_GlobalInvocationID.x > PushConstants.renderWidth || gl_GlobalInvocationID.y > PushConstants.renderHeight)
    {
        return;
    }

    const int numLayers = imageSize(i_outputImage).z;

    for (int layerIndex = 0; layerIndex < numLayers; ++layerIndex)
    {
        const vec4 outPixel = DoWork(layerIndex);

        imageStore(i_outputImage, ivec3(gl_GlobalInvocationID.xy, layerIndex), outPixel);
    }
}
